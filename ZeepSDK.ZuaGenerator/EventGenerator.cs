using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ZeepSDK.ZuaGenerator;

[Generator]
public class EventGenerator : IIncrementalGenerator
{
    private const string AttributeSource = @"// <auto-generated/>

namespace ZeepSDK.Scripting.Attributes
{
    [System.AttributeUsage(System.AttributeTargets.Event)]
    public class GenerateEventAttribute : System.Attribute
    {
    }
}";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(
            ctx => ctx.AddSource(
                "GenerateEventAttribute.g.cs",
                SourceText.From(AttributeSource, Encoding.UTF8)));

        IncrementalValuesProvider<EventFieldDeclarationSyntax> provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (node, ct) => node is EventFieldDeclarationSyntax,
                (ctx, ct) => GetEventDeclarationForSourceGen(ctx))
            .Where(x => x.reportAttributeFound)
            .Select((x, _) => x.syntax);
        
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateEventCode(ctx, t.Left, t.Right));
    }

    private static (EventFieldDeclarationSyntax syntax, bool reportAttributeFound) GetEventDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        EventFieldDeclarationSyntax nodeSyntax = (EventFieldDeclarationSyntax)context.Node;

        foreach (AttributeListSyntax attributeListSyntax in nodeSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                    continue;
        
                string attributeName = attributeSymbol.ContainingType.ToDisplayString();
        
                if (attributeName == "ZeepSDK.Scripting.Attributes.GenerateEventAttribute")
                    return (nodeSyntax, true);
            }
        }

        return (nodeSyntax, false);
    }

    private void GenerateEventCode(SourceProductionContext context, Compilation compilation, ImmutableArray<EventFieldDeclarationSyntax> events)
    {
        foreach (EventFieldDeclarationSyntax syntax in events)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
            
            foreach (VariableDeclaratorSyntax variable in syntax.Declaration.Variables)
            {
                string eventName = variable.Identifier.Text;

                if (semanticModel.GetDeclaredSymbol(variable) is not IEventSymbol symbol)
                    continue;

                string apiName = symbol.ContainingType.ToDisplayString();
                string className = symbol.ContainingType.Name + "_" + eventName + "_Event"; 

                if (symbol.Type is not INamedTypeSymbol delegateType || delegateType.TypeKind != TypeKind.Delegate)
                    continue;
                
                string delegateFullName = delegateType.ContainingNamespace.ToDisplayString() + "." + delegateType.Name;

                IMethodSymbol? invokeMethod = delegateType.DelegateInvokeMethod;
                if (invokeMethod == null) continue;

                ImmutableArray<IParameterSymbol> parameters = invokeMethod.Parameters;
                string delegateParameters = string.Join(", ", parameters.Select(p => p.Name));
                string callFunctionParameters = string.Join(", ", "Name", delegateParameters).TrimEnd(' ', ',');
                string typeRegistrations = string.Join(
                    "\r\n        ",
                    Utils.FilterTypes(parameters.Select(x => x.Type))
                        .Distinct(SymbolEqualityComparer.Default)
                        .Select(x => $"ScriptingApi.RegisterType<{x.ToDisplayString()}>();"));
                
                string generatedCode = $@"// <auto-generated/>
using JetBrains.Annotations;

namespace ZeepSDK.Scripting.Events;

[UsedImplicitly]
internal class {className} : ZeepSDK.Scripting.ZUA.ILuaEvent
{{
    private readonly {delegateFullName} @delegate;
    
    public string Name => ""{symbol.ContainingType.Name}.On{eventName}"";

    public {className}()
    {{
        @delegate = ({delegateParameters}) =>
        {{
            ScriptingApi.CallFunction({callFunctionParameters});
        }};
        {typeRegistrations}
    }}
    
    public void Subscribe()
    {{
        {apiName}.{eventName} += @delegate;
    }}

    public void Unsubscribe()
    {{
        {apiName}.{eventName} -= @delegate;
    }}
}}";
                
                context.AddSource($"{symbol.ContainingType.Name}.{eventName}.g.cs", SourceText.From(generatedCode, Encoding.UTF8));
            }
        }
    }


}
