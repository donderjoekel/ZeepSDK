using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ZeepSDK.ZuaGenerator;

[Generator]
public class PropertyGenerator : IIncrementalGenerator
{
    private const string GeneratePropertyAttributeSource = @"// <auto-generated/>

namespace ZeepSDK.Scripting.Attributes
{
    [System.AttributeUsage(System.AttributeTargets.Property)]
    public class GeneratePropertyAttribute : System.Attribute
    {
    }
}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(
            ctx => ctx.AddSource(
                "GeneratePropertyAttributeAttribute.g.cs",
                SourceText.From(GeneratePropertyAttributeSource, Encoding.UTF8)));

        IncrementalValuesProvider<PropertyDeclarationSyntax> provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (node, ct) => node is PropertyDeclarationSyntax,
                (ctx, ct) => GetPropertyDeclarationForSourceGen(ctx))
            .Where(x => x.reportAttributeFound)
            .Select((x, _) => x.syntax);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateFunctionCode(ctx, t.Left, t.Right));
    }

    private static (PropertyDeclarationSyntax syntax, bool reportAttributeFound) GetPropertyDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        PropertyDeclarationSyntax nodeSyntax = (PropertyDeclarationSyntax)context.Node;

        foreach (AttributeListSyntax attributeListSyntax in nodeSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                    continue;

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                if (attributeName == "ZeepSDK.Scripting.Attributes.GeneratePropertyAttribute")
                    return (nodeSyntax, true);
            }
        }

        return (nodeSyntax, false);
    }

    private void GenerateFunctionCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<PropertyDeclarationSyntax> properties)
    {
        foreach (PropertyDeclarationSyntax syntax in properties)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(syntax) is not IPropertySymbol symbol)
                continue;

            string @namespace = symbol.ContainingType.Name;
            string propertyName = symbol.Name;
            string className = "Get_" + symbol.ContainingType.Name + "_" + propertyName + "_Property";
            string api = symbol.ContainingType.ToDisplayString();
            string returnType = symbol.Type.ToDisplayString();
            // string typedParameters = string.Join(", ", symbol.Parameters.Select(x => $"{x.Type.ToDisplayString()} {x.Name}"));
            // string parameters = string.Join(", ", symbol.Parameters.Select(x => x.Name));
            // string returnString = symbol.ReturnsVoid ? "" : "return ";
            string typeRegistrations = string.Join(
                "\r\n        ",
                Utils.FilterType(symbol.Type)
                    .Distinct(SymbolEqualityComparer.Default)
                    .Select(x => $"ScriptingApi.RegisterType<{x.ToDisplayString()}>();"));
            
            string generatedCode = $@"// <auto-generated/>
using JetBrains.Annotations;

namespace ZeepSDK.Scripting.Functions;

[UsedImplicitly]
internal class {className} : ZeepSDK.Scripting.ZUA.ILuaFunction
{{
    public string Namespace => ""{@namespace}"";
    public string Name => ""{propertyName}"";

    public {className}()
    {{
        {typeRegistrations}
    }}

    public System.Delegate CreateFunction()
    {{
        return Implementation;
    }}

    private static {returnType} Implementation()
    {{
        return {api}.{propertyName};
    }}
}}";
            
            context.AddSource($"{@namespace}.{propertyName}.g.cs", SourceText.From(generatedCode, Encoding.UTF8));
        }
    }
}
